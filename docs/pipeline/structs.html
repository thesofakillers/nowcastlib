<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nowcastlib.pipeline.structs API documentation</title>
<meta name="description" content="Module containing custom structures used throughout the pipeline
submodule to aid with configuration …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nowcastlib.pipeline.structs</code></h1>
</header>
<section id="section-intro">
<p>Module containing custom structures used throughout the pipeline
submodule to aid with configuration.</p>
<p>A <code>Union</code> type annotation indicates that the variable
can be of any of the types listed in the <code>Union</code> type.
Variables whose type is <code>Union</code> with <code>NoneType</code> are optional.</p>
<p>Tuples are used instead of lists so to allow for hashing
of the struct instances. These should be treated as lists
when using .json files for specifying configuration.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module containing custom structures used throughout the pipeline
submodule to aid with configuration.

A `Union` type annotation indicates that the variable
can be of any of the types listed in the `Union` type.
Variables whose type is `Union` with `NoneType` are optional.

Tuples are used instead of lists so to allow for hashing
of the struct instances. These should be treated as lists
when using .json files for specifying configuration.
&#34;&#34;&#34;
from typing import Union, Tuple, Optional, Dict, Callable
from enum import Enum
from attr import attrs, attrib, validators
import numpy as np
import pandas as pd


def _enforce_npy(instance, attribute, value):
    &#34;&#34;&#34;ensures that the `output_format` key is `npy`&#34;&#34;&#34;
    if value is not None and value.output_format != &#34;npy&#34;:
        raise ValueError(
            &#34;&#39;{0}&#39;.output_path of the &#39;{1}&#39; instance needs to be `npy`&#34;
            &#34; A value of `{2}` was passed instead.&#34;.format(
                attribute.name, instance.__class__.__name__, value.output_format
            )
        )


def _normed_val(instance, attribute, value):
    &#34;&#34;&#34;Checks whether a given value is between 0 and 1&#34;&#34;&#34;
    if not 0 &lt;= value &lt;= 1:
        raise ValueError(
            &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance needs to be in the range [0, 1].&#34;
            &#34; A value of {2} was passed instead.&#34;.format(
                attribute.name, instance.__class__.__name__, value
            )
        )


def _normed_outlier_val(instance, attribute, value):
    &#34;&#34;&#34;Runs normed_validator if the outlier is quantile based&#34;&#34;&#34;
    if instance.quantile_based:
        _normed_val(instance, attribute, value)


@attrs(kw_only=True, frozen=True)
class ConversionOptions:
    &#34;&#34;&#34;
    Struct containing configuration options for the unit
    conversion of a given data field
    &#34;&#34;&#34;

    _conv_map: Dict[str, Callable] = {
        &#34;mph2ms&#34;: (lambda x: 0.44704 * x),
        &#34;deg2rad&#34;: np.deg2rad,
        &#34;rad2deg&#34;: np.rad2deg,
    }
    key: str = attrib(validator=validators.in_([*_conv_map.keys()]))
    &#34;&#34;&#34;
    One of &#39;mph2ms&#39;, &#39;deg2rad&#39; or &#39;rad2deg&#39; to specify what unit
    conversion to perform
    &#34;&#34;&#34;

    def conv_func(self, input_series):
        &#34;&#34;&#34;Function to use for converting the series as set by the key attribute&#34;&#34;&#34;
        return self._conv_map[self.key](input_series)


@attrs(kw_only=True, frozen=True)
class PeriodicOptions:
    &#34;&#34;&#34;
    Struct containing configuration options for the scaling of a
    given data field
    &#34;&#34;&#34;

    period_length: int = attrib()
    &#34;&#34;&#34;
    The sample number at which the signal starts repeating
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class OutlierOptions:
    &#34;&#34;&#34;
    Struct containing outlier handling configuration options
    of a given data field
    &#34;&#34;&#34;

    lower: float = attrib(default=0, validator=_normed_outlier_val)
    &#34;&#34;&#34;Lower inclusive (percentile) threshold, eliminating numbers lower than it&#34;&#34;&#34;
    upper: float = attrib(default=1, validator=_normed_outlier_val)
    &#34;&#34;&#34;Upper inclusive (percentile) threshold, eliminating numbers greater than it&#34;&#34;&#34;
    quantile_based: bool = attrib(default=True)
    &#34;&#34;&#34;
    Whether the lower and higher attributes are referring to quantiles.
    If `False`, `lower` and `higher` are treated as absolute thresholds.
    &#34;&#34;&#34;

    @upper.validator
    def _upper_gt_lower(self, attribute, value):
        &#34;&#34;&#34;validates whether higher &gt; lower&#34;&#34;&#34;
        if value &lt;= self.lower:
            raise ValueError(
                &#34;{0} of the {1} instance must be greater than the instance&#39;s&#34;
                &#34; &#39;lower&#39; attribute&#34;.format(attribute.name, self.__class__.__name__)
            )


@attrs(kw_only=True, frozen=True)
class SmoothOptions:
    &#34;&#34;&#34;
    Struct containing data smoothing configuration options
    of a given data field, achieved with a moving average operation.
    &#34;&#34;&#34;

    window_size: int = attrib()
    &#34;&#34;&#34;How large the window should be for a moving average operation&#34;&#34;&#34;
    units: Optional[str] = attrib(default=None)
    &#34;&#34;&#34;
    What units `window_size` is given in. Should be compatible with
    [pandas offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases).
    \nIf `None`, `window_size` refers to the number of samples comprising a window.
    &#34;&#34;&#34;

    @units.validator
    def _check_pd_offset_alias(self, attribute, value):
        &#34;&#34;&#34;checks whether the unit attribute is a valid pandas Offset alias&#34;&#34;&#34;
        if value is not None:
            try:
                pd.tseries.frequencies.to_offset(value)
            except ValueError as invalid_freq:
                error_string = (
                    &#34;{0} of the {1} instance must be an Offset Alias string&#34;
                    &#34; as specified at&#34;
                    &#34; https://pandas.pydata.org/pandas-docs&#34;
                    &#34;/stable/user_guide/timeseries.html#offset-aliases&#34;.format(
                        attribute.name, self.__class__.__name__
                    )
                )
                raise ValueError(error_string) from invalid_freq


class GeneratorFunction(Enum):
    &#34;&#34;&#34;Enumeration of the available Generator Functions&#34;&#34;&#34;

    T_SINCE_SUNSET = &#34;t_since_sunset&#34;
    &#34;&#34;&#34;seconds elapsed since the last sunset&#34;&#34;&#34;
    SIN_T_SINCE_SUNSET = &#34;sin_t_since_sunset&#34;
    &#34;&#34;&#34;sine of seconds elapsed since the last sunset out of 86400&#34;&#34;&#34;
    COS_T_SINCE_SUNSET = &#34;cos_t_since_sunset&#34;
    &#34;&#34;&#34;cosine of seconds elapsed since the last sunset out of 86400&#34;&#34;&#34;
    SUN_ELEVATION = &#34;sun_elevation&#34;
    &#34;&#34;&#34;the sun&#39;s current elevation&#34;&#34;&#34;
    SIN_SEC = &#34;sin_sec&#34;
    &#34;&#34;&#34;sine of the second number in the current day out of 86400&#34;&#34;&#34;
    COS_SEC = &#34;cos_sec&#34;
    &#34;&#34;&#34;cosine of the second number in the current day out of 86400&#34;&#34;&#34;
    SIN_DAY_YEAR = &#34;sin_day_year&#34;
    &#34;&#34;&#34;sine of the day number out of 365 in the current year&#34;&#34;&#34;
    COS_DAY_YEAR = &#34;cos_day_year&#34;
    &#34;&#34;&#34;cosine of the day number out of 365 in the current year&#34;&#34;&#34;
    SIN_DAY_WEEK = &#34;sin_day_week&#34;
    &#34;&#34;&#34;sine of the day number out of 7 in the current week&#34;&#34;&#34;
    COS_DAY_WEEK = &#34;cos_day_week&#34;
    &#34;&#34;&#34;cosine of the day number out of 7 in the current week&#34;&#34;&#34;
    SIN_MONTH_YEAR = &#34;sin_month_year&#34;
    &#34;&#34;&#34;sine of the month number out of 12 in the current year&#34;&#34;&#34;
    COS_MONTH_YEAR = &#34;cos_month_year&#34;
    &#34;&#34;&#34;cosine of the month number out of 12 in the current year&#34;&#34;&#34;
    IS_WEEKEND = &#34;is_weekend&#34;
    &#34;&#34;&#34;whether the current day is a friday, saturday or sunday&#34;&#34;&#34;
    CUSTOM = &#34;custom&#34;
    &#34;&#34;&#34;indicates the user will provide their own function&#34;&#34;&#34;


class StandardizationMethod(Enum):
    &#34;&#34;&#34;Enumeration of the available standardization methods&#34;&#34;&#34;

    POWER = &#34;power&#34;
    &#34;&#34;&#34;A power transform of the data (Yeo-Johnson)&#34;&#34;&#34;
    ROBUST = &#34;robust&#34;
    &#34;&#34;&#34;
    Rescales the data making use of its interquartile range.
    \nSee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html
    &#34;&#34;&#34;
    LOGNORM = &#34;lognorm&#34;
    &#34;&#34;&#34;Takes the logarithm of the data&#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class StandardizationOptions:
    &#34;&#34;&#34;
    Struct containing configuration options
    for standardizing a given field.
    &#34;&#34;&#34;

    method: StandardizationMethod = attrib()
    &#34;&#34;&#34;
    Which of the available methods to use. Specify as the
    Enum lowercase string value when configuring via JSON
    &#34;&#34;&#34;
    diagnostic_plots: bool = attrib(default=True)
    &#34;&#34;&#34;
    Whether or not to show diagnostic plots, intended to help
    the user in configuration evaluation and decision making.
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class BaseField:
    &#34;&#34;&#34;
    Struct containing configuration options
    shared by both Raw and Generated fields.
    &#34;&#34;&#34;

    std_options: Optional[StandardizationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for standardizing
    (scaling or normalizing) the field
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class GeneratedField(BaseField):
    &#34;&#34;&#34;
    Struct containing configuration for specifying
    how the pipeline should generate a new field of data
    &#34;&#34;&#34;

    target_name: str = attrib()
    &#34;&#34;&#34;
    What the new field should be named.
    &#34;&#34;&#34;
    input_fields: Tuple[str] = attrib()
    &#34;&#34;&#34;
    The names of the input fields to pass to the
    generator function as *args.
    &#34;index&#34;, to specify the index
    &#34;&#34;&#34;
    gen_func: GeneratorFunction = attrib()
    &#34;&#34;&#34;
    The name of the generator function to use
    for generating the new data. Specify as the
    Enum lowercase string value when configuring via JSON.
    &#34;&#34;&#34;
    additional_kwargs: Optional[dict] = attrib(default=None)
    &#34;&#34;&#34;
    a dictionary containing additional keyword arguments to
    to be passed to the function if necessary.
    &#34;&#34;&#34;
    func_path: Optional[str] = attrib(default=None)
    &#34;&#34;&#34;
    The path to the file implementing a custom
    generator function. To be specified if `gen_func` is `custom`
    &#34;&#34;&#34;

    @func_path.validator
    def only_if_custom(self, attribute, value):
        &#34;&#34;&#34;func_path should be defined only if the function is set to custom&#34;&#34;&#34;
        if value is not None:
            if self.gen_func != GeneratorFunction.CUSTOM:
                raise ValueError(
                    &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance should only be defined when the &#34;
                    &#34; instance&#39;s `gen_func` is set to `GeneratorFunction.CUSTOM`.&#34;
                    &#34; A value of {2} was passed instead.&#34;.format(
                        attribute.name, self.__class__.__name__, self.gen_func
                    )
                )


@attrs(kw_only=True, frozen=True)
class ProcessingOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for processing
    a given field of a given data source
    &#34;&#34;&#34;

    overwrite: bool = attrib(default=False)
    &#34;&#34;&#34;
    If `True`, overwrites the input field in the input dataframe.
    Otherwise appends a new field to the dataframe.
    Does not do anything when postprocessing.
    &#34;&#34;&#34;

    @overwrite.validator
    def prevent_overwrite(self, attribute, value):
        &#34;&#34;&#34;cannot overwrite if performing smoothing&#34;&#34;&#34;
        if value is True:
            if self.smooth_options is not None:
                raise ValueError(
                    &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance needs to be `False`&#34;
                    &#34; to perform smoothing. A value of {2} was passed instead.&#34;.format(
                        attribute.name, self.__class__.__name__, value
                    )
                )

    outlier_options: Optional[OutlierOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for specifying which outliers to drop.
    Is performed before any unit conversion.
    \nIf `None`, no outlier removal is performed.
    &#34;&#34;&#34;
    periodic_options: Optional[PeriodicOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for treating data that is periodic in nature,
    such as normalizing the desired range of values.
    Is performed before any unit conversion.
    \nIf `None`, no processing in this regard is performed.
    &#34;&#34;&#34;
    conversion_options: Optional[ConversionOptions] = attrib(
        default=None,
    )
    &#34;&#34;&#34;
    Configuration options for converting a field from one unit to another
    \nIf `None`, no conversion is performed.
    &#34;&#34;&#34;
    smooth_options: Optional[SmoothOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for smoothing the field.
    Is performed at the end of all other processing.
    \nIf `None`, no smoothing is performed.
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class RawField(BaseField):
    &#34;&#34;&#34;
    Struct containing configuration attributes for a raw field
    of a given DataSource
    &#34;&#34;&#34;

    field_name: str = attrib()
    &#34;&#34;&#34;The name of the field as specified in the input file&#34;&#34;&#34;
    is_date: bool = attrib(default=False)
    &#34;&#34;&#34;Whether the field is a date and therefore is the index of the DataSource&#34;&#34;&#34;
    date_format: str = attrib(default=&#34;%Y-%m-%dT%H:%M:%S&#34;)
    &#34;&#34;&#34;What format the date is presented in if the field is a date&#34;&#34;&#34;
    preprocessing_options: Optional[ProcessingOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for how to pre-process the field
    \nIf `None`, no preprocessing will be performed.
    &#34;&#34;&#34;
    postprocessing_options: Optional[ProcessingOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for how to post-process the field
    \nIf `None`, no post-processing will be performed.
    &#34;&#34;&#34;

    @is_date.validator
    def no_processing(self, _attribute, value):
        &#34;&#34;&#34;no processing or standardization to be performed when is_date is true&#34;&#34;&#34;
        if (value is True) and (
            (self.preprocessing_options is not None)
            or (self.postprocessing_options is not None)
            or (self.std_options is not None)
        ):
            raise ValueError(
                &#34;Cannot perform any standardization or (pre/post)processing on a date field.&#34;
                &#34;Please ensure that `std_options`, `preprocessing_options`,&#34;
                &#34; and `postprocessing_options` are all `None` for the field {}.&#34;
                &#34; Alternatively ensure `is_date` is `False`&#34;.format(self.field_name)
            )


@attrs(kw_only=True, frozen=True)
class SerializationOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for
    serializing a given DataSource to disk
    &#34;&#34;&#34;

    output_format: str = attrib(validator=validators.in_([&#34;csv&#34;, &#34;pickle&#34;, &#34;npy&#34;]))
    &#34;&#34;&#34;
    One of &#39;csv&#39;, &#39;pickle&#39; or &#39;npy&#39; to specify what format
    to save the DataSource as
    &#34;&#34;&#34;
    output_path: str = attrib()
    &#34;&#34;&#34;
    The desired path to the output file, including the name.
    Folders containing the output file should exist before running.
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class DataSource:
    &#34;&#34;&#34;
    Struct containing configuration attributes for processing
    an individual Data Source
    &#34;&#34;&#34;

    name: str = attrib()
    &#34;&#34;&#34;The name of the DataSource. Somewhat arbitrary but useful for legibility&#34;&#34;&#34;
    path: str = attrib()
    &#34;&#34;&#34;The path to the csv file from which to read the data&#34;&#34;&#34;
    fields: Tuple[RawField, ...] = attrib()
    &#34;&#34;&#34;Configuration options for each field the user is interested in&#34;&#34;&#34;
    comment_format: str = attrib(default=&#34;#&#34;)
    &#34;&#34;&#34;Prefix used in csv file to signal comments, that will be dropped when reading&#34;&#34;&#34;
    preprocessing_output: Optional[SerializationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for saving the preprocessing results to disk.
    \nIf `None`, no serialization of the preprocessing results will be performed.
    &#34;&#34;&#34;

    @fields.validator
    def _exactly_one_date(self, attribute, value):
        &#34;&#34;&#34;checks whether maximum one of the fields contains date information&#34;&#34;&#34;
        date_flags = [field.is_date for field in value if field.is_date]
        if len(date_flags) &gt; 1:
            raise ValueError(
                &#34;{0} of the {1} instance must contain exactly one RawField with&#34;
                &#34; is_date=True&#34;.format(attribute.name, self.__class__.__name__)
            )


@attrs(kw_only=True, frozen=True)
class ChunkOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for chunking
    a partially synchronized DataSet
    &#34;&#34;&#34;

    max_gap_size: int = attrib()
    &#34;&#34;&#34;
    The maximum amount of time in seconds for a gap to be ignored
    &#34;&#34;&#34;
    min_chunk_size: int = attrib()
    &#34;&#34;&#34;
    The minimum length in seconds for contiguous block of data
    to be considered.
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class SyncOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for synchronizing
    a DataSet
    &#34;&#34;&#34;

    sample_spacing: int = attrib()
    &#34;&#34;&#34;
    The desired amount of time in seconds between each sample.
    \nIf `None`, no re-sampling will be performed.
    &#34;&#34;&#34;
    chunk_options: ChunkOptions = attrib()
    &#34;&#34;&#34;
    Configuration options necessary for handling chunking operations.
    &#34;&#34;&#34;
    data_output: Optional[SerializationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for saving the resulting
    synchronized dataframe to disk.
    \nIf `None`, no serialization of the preprocessing results will be performed.
    &#34;&#34;&#34;
    chunks_output: Optional[SerializationOptions] = attrib(
        default=None, validator=_enforce_npy
    )
    &#34;&#34;&#34;
    Configuration options for saving the detected
    chunk locations to disk. Only &#39;npy&#39; output_format
    is accepted.
    \nIf `None`, no serialization of the preprocessing results will be performed.
    &#34;&#34;&#34;
    diagnostic_plots: bool = attrib(default=True)
    &#34;&#34;&#34;
    Whether or not to show diagnostic plots, intended to help
    the user in configuration evaluation and decision making.
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class ValidationOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for
    configuring model validation
    &#34;&#34;&#34;

    train_extent: float = attrib(default=0.6, validator=[_normed_val])
    &#34;&#34;&#34;
    Percentage of the data to allocate to the training set.
    &#34;&#34;&#34;
    val_extent: float = attrib(default=0.1, validator=[_normed_val])
    &#34;&#34;&#34;
    Percentage of the data to allocate to the validation set.
    &#34;&#34;&#34;
    iterations: int = attrib(default=5)
    &#34;&#34;&#34;
    How many splits to make. Must be at least 3.
    &#34;&#34;&#34;

    @iterations.validator
    def at_least_3(self, attribute, value):
        &#34;&#34;&#34;ensures at least 3 iterations are used for validation&#34;&#34;&#34;
        if value &lt; 3:
            raise ValueError(
                &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance needs to be at least 3.&#34;
                &#34; A value of {2} was passed instead.&#34;.format(
                    attribute.name, self.__class__.__name__, value
                )
            )


@attrs(kw_only=True, frozen=True)
class DirSerializationOptions:
    &#34;&#34;&#34;
    Struct configuration attributes for serializing
    to specific directories, used for organizing splits
    &#34;&#34;&#34;

    parent_path: str = attrib()
    &#34;&#34;&#34;
    The path to the directory where to serialize the resulting splits.
    Within the directory, 2 subdirectories will be created: `main_split/`
    and `cv_split`, respectively storing the main split and the cross
    validation split.
    &#34;&#34;&#34;
    overwrite: bool = attrib(default=False)
    &#34;&#34;&#34;
    Whether to overwrite existing directories and files if they exist
    already. Default `False`
    &#34;&#34;&#34;
    create_parents: bool = attrib(default=False)
    &#34;&#34;&#34;
    Whether parent directories of `parent_path` should be created
    if they do not exist
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class SplitOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for
    model evaluation
    &#34;&#34;&#34;

    train_split: Union[int, float, str] = attrib()
    &#34;&#34;&#34;
    The index, percentage or date to use as the final
    point in the training set. The closest non-nan row will be used.
    &#34;&#34;&#34;
    validation: ValidationOptions = attrib()
    &#34;&#34;&#34;
    Configuration options for further splits of the data for validation.
    &#34;&#34;&#34;
    output_options: Optional[DirSerializationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for serializing the resulting splits
    in organized directories.
    \nIf `None`, no serialization will be performed.
    &#34;&#34;&#34;


@attrs(kw_only=True, frozen=True)
class DataSet:
    &#34;&#34;&#34;
    Struct containing configuration attributes for processing
    a set of Data Sources
    &#34;&#34;&#34;

    data_sources: Tuple[DataSource, ...] = attrib()
    &#34;&#34;&#34;
    Configuration options for each of the sources of data we wish
    to process, each originating from a different file.
    &#34;&#34;&#34;
    sync_options: Optional[SyncOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configurations options for synchronizing the `data_sources`.
    \nIf `None`, no synchronization will be performed
    &#34;&#34;&#34;
    split_options: Optional[SplitOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configurations options for handling data splitting.
    \nIf `None`, no splitting will be performed
    &#34;&#34;&#34;
    generated_fields: Optional[Tuple[GeneratedField]] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for adding new fields to the data.
    \nIf `None`, no new fields will be computed.
    &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nowcastlib.pipeline.structs.ConversionOptions"><code class="flex name class">
<span>class <span class="ident">ConversionOptions</span></span>
<span>(</span><span>*, key: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration options for the unit
conversion of a given data field</p>
<p>Method generated by attrs for class ConversionOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConversionOptions:
    &#34;&#34;&#34;
    Struct containing configuration options for the unit
    conversion of a given data field
    &#34;&#34;&#34;

    _conv_map: Dict[str, Callable] = {
        &#34;mph2ms&#34;: (lambda x: 0.44704 * x),
        &#34;deg2rad&#34;: np.deg2rad,
        &#34;rad2deg&#34;: np.rad2deg,
    }
    key: str = attrib(validator=validators.in_([*_conv_map.keys()]))
    &#34;&#34;&#34;
    One of &#39;mph2ms&#39;, &#39;deg2rad&#39; or &#39;rad2deg&#39; to specify what unit
    conversion to perform
    &#34;&#34;&#34;

    def conv_func(self, input_series):
        &#34;&#34;&#34;Function to use for converting the series as set by the key attribute&#34;&#34;&#34;
        return self._conv_map[self.key](input_series)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.ConversionOptions.key"><code class="name">var <span class="ident">key</span> : str</code></dt>
<dd>
<div class="desc"><p>One of 'mph2ms', 'deg2rad' or 'rad2deg' to specify what unit
conversion to perform</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.ConversionOptions.conv_func"><code class="name flex">
<span>def <span class="ident">conv_func</span></span>(<span>self, input_series)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to use for converting the series as set by the key attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conv_func(self, input_series):
    &#34;&#34;&#34;Function to use for converting the series as set by the key attribute&#34;&#34;&#34;
    return self._conv_map[self.key](input_series)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.PeriodicOptions"><code class="flex name class">
<span>class <span class="ident">PeriodicOptions</span></span>
<span>(</span><span>*, period_length: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration options for the scaling of a
given data field</p>
<p>Method generated by attrs for class PeriodicOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PeriodicOptions:
    &#34;&#34;&#34;
    Struct containing configuration options for the scaling of a
    given data field
    &#34;&#34;&#34;

    period_length: int = attrib()
    &#34;&#34;&#34;
    The sample number at which the signal starts repeating
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.PeriodicOptions.period_length"><code class="name">var <span class="ident">period_length</span> : int</code></dt>
<dd>
<div class="desc"><p>The sample number at which the signal starts repeating</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.OutlierOptions"><code class="flex name class">
<span>class <span class="ident">OutlierOptions</span></span>
<span>(</span><span>*, lower: float = 0, upper: float = 1, quantile_based: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing outlier handling configuration options
of a given data field</p>
<p>Method generated by attrs for class OutlierOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutlierOptions:
    &#34;&#34;&#34;
    Struct containing outlier handling configuration options
    of a given data field
    &#34;&#34;&#34;

    lower: float = attrib(default=0, validator=_normed_outlier_val)
    &#34;&#34;&#34;Lower inclusive (percentile) threshold, eliminating numbers lower than it&#34;&#34;&#34;
    upper: float = attrib(default=1, validator=_normed_outlier_val)
    &#34;&#34;&#34;Upper inclusive (percentile) threshold, eliminating numbers greater than it&#34;&#34;&#34;
    quantile_based: bool = attrib(default=True)
    &#34;&#34;&#34;
    Whether the lower and higher attributes are referring to quantiles.
    If `False`, `lower` and `higher` are treated as absolute thresholds.
    &#34;&#34;&#34;

    @upper.validator
    def _upper_gt_lower(self, attribute, value):
        &#34;&#34;&#34;validates whether higher &gt; lower&#34;&#34;&#34;
        if value &lt;= self.lower:
            raise ValueError(
                &#34;{0} of the {1} instance must be greater than the instance&#39;s&#34;
                &#34; &#39;lower&#39; attribute&#34;.format(attribute.name, self.__class__.__name__)
            )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.OutlierOptions.lower"><code class="name">var <span class="ident">lower</span> : float</code></dt>
<dd>
<div class="desc"><p>Lower inclusive (percentile) threshold, eliminating numbers lower than it</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.OutlierOptions.upper"><code class="name">var <span class="ident">upper</span> : float</code></dt>
<dd>
<div class="desc"><p>Upper inclusive (percentile) threshold, eliminating numbers greater than it</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.OutlierOptions.quantile_based"><code class="name">var <span class="ident">quantile_based</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether the lower and higher attributes are referring to quantiles.
If <code>False</code>, <code>lower</code> and <code>higher</code> are treated as absolute thresholds.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.SmoothOptions"><code class="flex name class">
<span>class <span class="ident">SmoothOptions</span></span>
<span>(</span><span>*, window_size: int, units: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing data smoothing configuration options
of a given data field, achieved with a moving average operation.</p>
<p>Method generated by attrs for class SmoothOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SmoothOptions:
    &#34;&#34;&#34;
    Struct containing data smoothing configuration options
    of a given data field, achieved with a moving average operation.
    &#34;&#34;&#34;

    window_size: int = attrib()
    &#34;&#34;&#34;How large the window should be for a moving average operation&#34;&#34;&#34;
    units: Optional[str] = attrib(default=None)
    &#34;&#34;&#34;
    What units `window_size` is given in. Should be compatible with
    [pandas offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases).
    \nIf `None`, `window_size` refers to the number of samples comprising a window.
    &#34;&#34;&#34;

    @units.validator
    def _check_pd_offset_alias(self, attribute, value):
        &#34;&#34;&#34;checks whether the unit attribute is a valid pandas Offset alias&#34;&#34;&#34;
        if value is not None:
            try:
                pd.tseries.frequencies.to_offset(value)
            except ValueError as invalid_freq:
                error_string = (
                    &#34;{0} of the {1} instance must be an Offset Alias string&#34;
                    &#34; as specified at&#34;
                    &#34; https://pandas.pydata.org/pandas-docs&#34;
                    &#34;/stable/user_guide/timeseries.html#offset-aliases&#34;.format(
                        attribute.name, self.__class__.__name__
                    )
                )
                raise ValueError(error_string) from invalid_freq</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.SmoothOptions.window_size"><code class="name">var <span class="ident">window_size</span> : int</code></dt>
<dd>
<div class="desc"><p>How large the window should be for a moving average operation</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SmoothOptions.units"><code class="name">var <span class="ident">units</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>What units <code>window_size</code> is given in. Should be compatible with
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases">pandas offset aliases</a>.</p>
<p>If <code>None</code>, <code>window_size</code> refers to the number of samples comprising a window.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction"><code class="flex name class">
<span>class <span class="ident">GeneratorFunction</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of the available Generator Functions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneratorFunction(Enum):
    &#34;&#34;&#34;Enumeration of the available Generator Functions&#34;&#34;&#34;

    T_SINCE_SUNSET = &#34;t_since_sunset&#34;
    &#34;&#34;&#34;seconds elapsed since the last sunset&#34;&#34;&#34;
    SIN_T_SINCE_SUNSET = &#34;sin_t_since_sunset&#34;
    &#34;&#34;&#34;sine of seconds elapsed since the last sunset out of 86400&#34;&#34;&#34;
    COS_T_SINCE_SUNSET = &#34;cos_t_since_sunset&#34;
    &#34;&#34;&#34;cosine of seconds elapsed since the last sunset out of 86400&#34;&#34;&#34;
    SUN_ELEVATION = &#34;sun_elevation&#34;
    &#34;&#34;&#34;the sun&#39;s current elevation&#34;&#34;&#34;
    SIN_SEC = &#34;sin_sec&#34;
    &#34;&#34;&#34;sine of the second number in the current day out of 86400&#34;&#34;&#34;
    COS_SEC = &#34;cos_sec&#34;
    &#34;&#34;&#34;cosine of the second number in the current day out of 86400&#34;&#34;&#34;
    SIN_DAY_YEAR = &#34;sin_day_year&#34;
    &#34;&#34;&#34;sine of the day number out of 365 in the current year&#34;&#34;&#34;
    COS_DAY_YEAR = &#34;cos_day_year&#34;
    &#34;&#34;&#34;cosine of the day number out of 365 in the current year&#34;&#34;&#34;
    SIN_DAY_WEEK = &#34;sin_day_week&#34;
    &#34;&#34;&#34;sine of the day number out of 7 in the current week&#34;&#34;&#34;
    COS_DAY_WEEK = &#34;cos_day_week&#34;
    &#34;&#34;&#34;cosine of the day number out of 7 in the current week&#34;&#34;&#34;
    SIN_MONTH_YEAR = &#34;sin_month_year&#34;
    &#34;&#34;&#34;sine of the month number out of 12 in the current year&#34;&#34;&#34;
    COS_MONTH_YEAR = &#34;cos_month_year&#34;
    &#34;&#34;&#34;cosine of the month number out of 12 in the current year&#34;&#34;&#34;
    IS_WEEKEND = &#34;is_weekend&#34;
    &#34;&#34;&#34;whether the current day is a friday, saturday or sunday&#34;&#34;&#34;
    CUSTOM = &#34;custom&#34;
    &#34;&#34;&#34;indicates the user will provide their own function&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.T_SINCE_SUNSET"><code class="name">var <span class="ident">T_SINCE_SUNSET</span></code></dt>
<dd>
<div class="desc"><p>seconds elapsed since the last sunset</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.SIN_T_SINCE_SUNSET"><code class="name">var <span class="ident">SIN_T_SINCE_SUNSET</span></code></dt>
<dd>
<div class="desc"><p>sine of seconds elapsed since the last sunset out of 86400</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.COS_T_SINCE_SUNSET"><code class="name">var <span class="ident">COS_T_SINCE_SUNSET</span></code></dt>
<dd>
<div class="desc"><p>cosine of seconds elapsed since the last sunset out of 86400</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.SUN_ELEVATION"><code class="name">var <span class="ident">SUN_ELEVATION</span></code></dt>
<dd>
<div class="desc"><p>the sun's current elevation</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.SIN_SEC"><code class="name">var <span class="ident">SIN_SEC</span></code></dt>
<dd>
<div class="desc"><p>sine of the second number in the current day out of 86400</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.COS_SEC"><code class="name">var <span class="ident">COS_SEC</span></code></dt>
<dd>
<div class="desc"><p>cosine of the second number in the current day out of 86400</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.SIN_DAY_YEAR"><code class="name">var <span class="ident">SIN_DAY_YEAR</span></code></dt>
<dd>
<div class="desc"><p>sine of the day number out of 365 in the current year</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.COS_DAY_YEAR"><code class="name">var <span class="ident">COS_DAY_YEAR</span></code></dt>
<dd>
<div class="desc"><p>cosine of the day number out of 365 in the current year</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.SIN_DAY_WEEK"><code class="name">var <span class="ident">SIN_DAY_WEEK</span></code></dt>
<dd>
<div class="desc"><p>sine of the day number out of 7 in the current week</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.COS_DAY_WEEK"><code class="name">var <span class="ident">COS_DAY_WEEK</span></code></dt>
<dd>
<div class="desc"><p>cosine of the day number out of 7 in the current week</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.SIN_MONTH_YEAR"><code class="name">var <span class="ident">SIN_MONTH_YEAR</span></code></dt>
<dd>
<div class="desc"><p>sine of the month number out of 12 in the current year</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.COS_MONTH_YEAR"><code class="name">var <span class="ident">COS_MONTH_YEAR</span></code></dt>
<dd>
<div class="desc"><p>cosine of the month number out of 12 in the current year</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.IS_WEEKEND"><code class="name">var <span class="ident">IS_WEEKEND</span></code></dt>
<dd>
<div class="desc"><p>whether the current day is a friday, saturday or sunday</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratorFunction.CUSTOM"><code class="name">var <span class="ident">CUSTOM</span></code></dt>
<dd>
<div class="desc"><p>indicates the user will provide their own function</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.StandardizationMethod"><code class="flex name class">
<span>class <span class="ident">StandardizationMethod</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of the available standardization methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StandardizationMethod(Enum):
    &#34;&#34;&#34;Enumeration of the available standardization methods&#34;&#34;&#34;

    POWER = &#34;power&#34;
    &#34;&#34;&#34;A power transform of the data (Yeo-Johnson)&#34;&#34;&#34;
    ROBUST = &#34;robust&#34;
    &#34;&#34;&#34;
    Rescales the data making use of its interquartile range.
    \nSee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html
    &#34;&#34;&#34;
    LOGNORM = &#34;lognorm&#34;
    &#34;&#34;&#34;Takes the logarithm of the data&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.StandardizationMethod.POWER"><code class="name">var <span class="ident">POWER</span></code></dt>
<dd>
<div class="desc"><p>A power transform of the data (Yeo-Johnson)</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.StandardizationMethod.ROBUST"><code class="name">var <span class="ident">ROBUST</span></code></dt>
<dd>
<div class="desc"><p>Rescales the data making use of its interquartile range.</p>
<p>See <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html</a></p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.StandardizationMethod.LOGNORM"><code class="name">var <span class="ident">LOGNORM</span></code></dt>
<dd>
<div class="desc"><p>Takes the logarithm of the data</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.StandardizationOptions"><code class="flex name class">
<span>class <span class="ident">StandardizationOptions</span></span>
<span>(</span><span>*, method: <a title="nowcastlib.pipeline.structs.StandardizationMethod" href="#nowcastlib.pipeline.structs.StandardizationMethod">StandardizationMethod</a>, diagnostic_plots: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration options
for standardizing a given field.</p>
<p>Method generated by attrs for class StandardizationOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StandardizationOptions:
    &#34;&#34;&#34;
    Struct containing configuration options
    for standardizing a given field.
    &#34;&#34;&#34;

    method: StandardizationMethod = attrib()
    &#34;&#34;&#34;
    Which of the available methods to use. Specify as the
    Enum lowercase string value when configuring via JSON
    &#34;&#34;&#34;
    diagnostic_plots: bool = attrib(default=True)
    &#34;&#34;&#34;
    Whether or not to show diagnostic plots, intended to help
    the user in configuration evaluation and decision making.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.StandardizationOptions.method"><code class="name">var <span class="ident">method</span> : <a title="nowcastlib.pipeline.structs.StandardizationMethod" href="#nowcastlib.pipeline.structs.StandardizationMethod">StandardizationMethod</a></code></dt>
<dd>
<div class="desc"><p>Which of the available methods to use. Specify as the
Enum lowercase string value when configuring via JSON</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.StandardizationOptions.diagnostic_plots"><code class="name">var <span class="ident">diagnostic_plots</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether or not to show diagnostic plots, intended to help
the user in configuration evaluation and decision making.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.BaseField"><code class="flex name class">
<span>class <span class="ident">BaseField</span></span>
<span>(</span><span>*, std_options: Union[<a title="nowcastlib.pipeline.structs.StandardizationOptions" href="#nowcastlib.pipeline.structs.StandardizationOptions">StandardizationOptions</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration options
shared by both Raw and Generated fields.</p>
<p>Method generated by attrs for class BaseField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseField:
    &#34;&#34;&#34;
    Struct containing configuration options
    shared by both Raw and Generated fields.
    &#34;&#34;&#34;

    std_options: Optional[StandardizationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for standardizing
    (scaling or normalizing) the field
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nowcastlib.pipeline.structs.GeneratedField" href="#nowcastlib.pipeline.structs.GeneratedField">GeneratedField</a></li>
<li><a title="nowcastlib.pipeline.structs.RawField" href="#nowcastlib.pipeline.structs.RawField">RawField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.BaseField.std_options"><code class="name">var <span class="ident">std_options</span> : Union[<a title="nowcastlib.pipeline.structs.StandardizationOptions" href="#nowcastlib.pipeline.structs.StandardizationOptions">StandardizationOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for standardizing
(scaling or normalizing) the field</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratedField"><code class="flex name class">
<span>class <span class="ident">GeneratedField</span></span>
<span>(</span><span>*, std_options: Union[<a title="nowcastlib.pipeline.structs.StandardizationOptions" href="#nowcastlib.pipeline.structs.StandardizationOptions">StandardizationOptions</a>, NoneType] = None, target_name: str, input_fields: Tuple[str], gen_func: <a title="nowcastlib.pipeline.structs.GeneratorFunction" href="#nowcastlib.pipeline.structs.GeneratorFunction">GeneratorFunction</a>, additional_kwargs: Union[dict, NoneType] = None, func_path: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration for specifying
how the pipeline should generate a new field of data</p>
<p>Method generated by attrs for class GeneratedField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneratedField(BaseField):
    &#34;&#34;&#34;
    Struct containing configuration for specifying
    how the pipeline should generate a new field of data
    &#34;&#34;&#34;

    target_name: str = attrib()
    &#34;&#34;&#34;
    What the new field should be named.
    &#34;&#34;&#34;
    input_fields: Tuple[str] = attrib()
    &#34;&#34;&#34;
    The names of the input fields to pass to the
    generator function as *args.
    &#34;index&#34;, to specify the index
    &#34;&#34;&#34;
    gen_func: GeneratorFunction = attrib()
    &#34;&#34;&#34;
    The name of the generator function to use
    for generating the new data. Specify as the
    Enum lowercase string value when configuring via JSON.
    &#34;&#34;&#34;
    additional_kwargs: Optional[dict] = attrib(default=None)
    &#34;&#34;&#34;
    a dictionary containing additional keyword arguments to
    to be passed to the function if necessary.
    &#34;&#34;&#34;
    func_path: Optional[str] = attrib(default=None)
    &#34;&#34;&#34;
    The path to the file implementing a custom
    generator function. To be specified if `gen_func` is `custom`
    &#34;&#34;&#34;

    @func_path.validator
    def only_if_custom(self, attribute, value):
        &#34;&#34;&#34;func_path should be defined only if the function is set to custom&#34;&#34;&#34;
        if value is not None:
            if self.gen_func != GeneratorFunction.CUSTOM:
                raise ValueError(
                    &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance should only be defined when the &#34;
                    &#34; instance&#39;s `gen_func` is set to `GeneratorFunction.CUSTOM`.&#34;
                    &#34; A value of {2} was passed instead.&#34;.format(
                        attribute.name, self.__class__.__name__, self.gen_func
                    )
                )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nowcastlib.pipeline.structs.BaseField" href="#nowcastlib.pipeline.structs.BaseField">BaseField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.GeneratedField.target_name"><code class="name">var <span class="ident">target_name</span> : str</code></dt>
<dd>
<div class="desc"><p>What the new field should be named.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratedField.input_fields"><code class="name">var <span class="ident">input_fields</span> : Tuple[str]</code></dt>
<dd>
<div class="desc"><p>The names of the input fields to pass to the
generator function as *args.
"index", to specify the index</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratedField.gen_func"><code class="name">var <span class="ident">gen_func</span> : <a title="nowcastlib.pipeline.structs.GeneratorFunction" href="#nowcastlib.pipeline.structs.GeneratorFunction">GeneratorFunction</a></code></dt>
<dd>
<div class="desc"><p>The name of the generator function to use
for generating the new data. Specify as the
Enum lowercase string value when configuring via JSON.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratedField.additional_kwargs"><code class="name">var <span class="ident">additional_kwargs</span> : Union[dict, NoneType]</code></dt>
<dd>
<div class="desc"><p>a dictionary containing additional keyword arguments to
to be passed to the function if necessary.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.GeneratedField.func_path"><code class="name">var <span class="ident">func_path</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>The path to the file implementing a custom
generator function. To be specified if <code>gen_func</code> is <code>custom</code></p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.GeneratedField.only_if_custom"><code class="name flex">
<span>def <span class="ident">only_if_custom</span></span>(<span>self, attribute, value)</span>
</code></dt>
<dd>
<div class="desc"><p>func_path should be defined only if the function is set to custom</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@func_path.validator
def only_if_custom(self, attribute, value):
    &#34;&#34;&#34;func_path should be defined only if the function is set to custom&#34;&#34;&#34;
    if value is not None:
        if self.gen_func != GeneratorFunction.CUSTOM:
            raise ValueError(
                &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance should only be defined when the &#34;
                &#34; instance&#39;s `gen_func` is set to `GeneratorFunction.CUSTOM`.&#34;
                &#34; A value of {2} was passed instead.&#34;.format(
                    attribute.name, self.__class__.__name__, self.gen_func
                )
            )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nowcastlib.pipeline.structs.BaseField" href="#nowcastlib.pipeline.structs.BaseField">BaseField</a></b></code>:
<ul class="hlist">
<li><code><a title="nowcastlib.pipeline.structs.BaseField.std_options" href="#nowcastlib.pipeline.structs.BaseField.std_options">std_options</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nowcastlib.pipeline.structs.ProcessingOptions"><code class="flex name class">
<span>class <span class="ident">ProcessingOptions</span></span>
<span>(</span><span>*, overwrite: bool = False, outlier_options: Union[<a title="nowcastlib.pipeline.structs.OutlierOptions" href="#nowcastlib.pipeline.structs.OutlierOptions">OutlierOptions</a>, NoneType] = None, periodic_options: Union[<a title="nowcastlib.pipeline.structs.PeriodicOptions" href="#nowcastlib.pipeline.structs.PeriodicOptions">PeriodicOptions</a>, NoneType] = None, conversion_options: Union[<a title="nowcastlib.pipeline.structs.ConversionOptions" href="#nowcastlib.pipeline.structs.ConversionOptions">ConversionOptions</a>, NoneType] = None, smooth_options: Union[<a title="nowcastlib.pipeline.structs.SmoothOptions" href="#nowcastlib.pipeline.structs.SmoothOptions">SmoothOptions</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for processing
a given field of a given data source</p>
<p>Method generated by attrs for class ProcessingOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessingOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for processing
    a given field of a given data source
    &#34;&#34;&#34;

    overwrite: bool = attrib(default=False)
    &#34;&#34;&#34;
    If `True`, overwrites the input field in the input dataframe.
    Otherwise appends a new field to the dataframe.
    Does not do anything when postprocessing.
    &#34;&#34;&#34;

    @overwrite.validator
    def prevent_overwrite(self, attribute, value):
        &#34;&#34;&#34;cannot overwrite if performing smoothing&#34;&#34;&#34;
        if value is True:
            if self.smooth_options is not None:
                raise ValueError(
                    &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance needs to be `False`&#34;
                    &#34; to perform smoothing. A value of {2} was passed instead.&#34;.format(
                        attribute.name, self.__class__.__name__, value
                    )
                )

    outlier_options: Optional[OutlierOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for specifying which outliers to drop.
    Is performed before any unit conversion.
    \nIf `None`, no outlier removal is performed.
    &#34;&#34;&#34;
    periodic_options: Optional[PeriodicOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for treating data that is periodic in nature,
    such as normalizing the desired range of values.
    Is performed before any unit conversion.
    \nIf `None`, no processing in this regard is performed.
    &#34;&#34;&#34;
    conversion_options: Optional[ConversionOptions] = attrib(
        default=None,
    )
    &#34;&#34;&#34;
    Configuration options for converting a field from one unit to another
    \nIf `None`, no conversion is performed.
    &#34;&#34;&#34;
    smooth_options: Optional[SmoothOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for smoothing the field.
    Is performed at the end of all other processing.
    \nIf `None`, no smoothing is performed.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.ProcessingOptions.overwrite"><code class="name">var <span class="ident">overwrite</span> : bool</code></dt>
<dd>
<div class="desc"><p>If <code>True</code>, overwrites the input field in the input dataframe.
Otherwise appends a new field to the dataframe.
Does not do anything when postprocessing.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.ProcessingOptions.outlier_options"><code class="name">var <span class="ident">outlier_options</span> : Union[<a title="nowcastlib.pipeline.structs.OutlierOptions" href="#nowcastlib.pipeline.structs.OutlierOptions">OutlierOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for specifying which outliers to drop.
Is performed before any unit conversion.</p>
<p>If <code>None</code>, no outlier removal is performed.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.ProcessingOptions.periodic_options"><code class="name">var <span class="ident">periodic_options</span> : Union[<a title="nowcastlib.pipeline.structs.PeriodicOptions" href="#nowcastlib.pipeline.structs.PeriodicOptions">PeriodicOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for treating data that is periodic in nature,
such as normalizing the desired range of values.
Is performed before any unit conversion.</p>
<p>If <code>None</code>, no processing in this regard is performed.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.ProcessingOptions.conversion_options"><code class="name">var <span class="ident">conversion_options</span> : Union[<a title="nowcastlib.pipeline.structs.ConversionOptions" href="#nowcastlib.pipeline.structs.ConversionOptions">ConversionOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for converting a field from one unit to another</p>
<p>If <code>None</code>, no conversion is performed.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.ProcessingOptions.smooth_options"><code class="name">var <span class="ident">smooth_options</span> : Union[<a title="nowcastlib.pipeline.structs.SmoothOptions" href="#nowcastlib.pipeline.structs.SmoothOptions">SmoothOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for smoothing the field.
Is performed at the end of all other processing.</p>
<p>If <code>None</code>, no smoothing is performed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.ProcessingOptions.prevent_overwrite"><code class="name flex">
<span>def <span class="ident">prevent_overwrite</span></span>(<span>self, attribute, value)</span>
</code></dt>
<dd>
<div class="desc"><p>cannot overwrite if performing smoothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@overwrite.validator
def prevent_overwrite(self, attribute, value):
    &#34;&#34;&#34;cannot overwrite if performing smoothing&#34;&#34;&#34;
    if value is True:
        if self.smooth_options is not None:
            raise ValueError(
                &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance needs to be `False`&#34;
                &#34; to perform smoothing. A value of {2} was passed instead.&#34;.format(
                    attribute.name, self.__class__.__name__, value
                )
            )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.RawField"><code class="flex name class">
<span>class <span class="ident">RawField</span></span>
<span>(</span><span>*, std_options: Union[<a title="nowcastlib.pipeline.structs.StandardizationOptions" href="#nowcastlib.pipeline.structs.StandardizationOptions">StandardizationOptions</a>, NoneType] = None, field_name: str, is_date: bool = False, date_format: str = '%Y-%m-%dT%H:%M:%S', preprocessing_options: Union[<a title="nowcastlib.pipeline.structs.ProcessingOptions" href="#nowcastlib.pipeline.structs.ProcessingOptions">ProcessingOptions</a>, NoneType] = None, postprocessing_options: Union[<a title="nowcastlib.pipeline.structs.ProcessingOptions" href="#nowcastlib.pipeline.structs.ProcessingOptions">ProcessingOptions</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for a raw field
of a given DataSource</p>
<p>Method generated by attrs for class RawField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawField(BaseField):
    &#34;&#34;&#34;
    Struct containing configuration attributes for a raw field
    of a given DataSource
    &#34;&#34;&#34;

    field_name: str = attrib()
    &#34;&#34;&#34;The name of the field as specified in the input file&#34;&#34;&#34;
    is_date: bool = attrib(default=False)
    &#34;&#34;&#34;Whether the field is a date and therefore is the index of the DataSource&#34;&#34;&#34;
    date_format: str = attrib(default=&#34;%Y-%m-%dT%H:%M:%S&#34;)
    &#34;&#34;&#34;What format the date is presented in if the field is a date&#34;&#34;&#34;
    preprocessing_options: Optional[ProcessingOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for how to pre-process the field
    \nIf `None`, no preprocessing will be performed.
    &#34;&#34;&#34;
    postprocessing_options: Optional[ProcessingOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for how to post-process the field
    \nIf `None`, no post-processing will be performed.
    &#34;&#34;&#34;

    @is_date.validator
    def no_processing(self, _attribute, value):
        &#34;&#34;&#34;no processing or standardization to be performed when is_date is true&#34;&#34;&#34;
        if (value is True) and (
            (self.preprocessing_options is not None)
            or (self.postprocessing_options is not None)
            or (self.std_options is not None)
        ):
            raise ValueError(
                &#34;Cannot perform any standardization or (pre/post)processing on a date field.&#34;
                &#34;Please ensure that `std_options`, `preprocessing_options`,&#34;
                &#34; and `postprocessing_options` are all `None` for the field {}.&#34;
                &#34; Alternatively ensure `is_date` is `False`&#34;.format(self.field_name)
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nowcastlib.pipeline.structs.BaseField" href="#nowcastlib.pipeline.structs.BaseField">BaseField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.RawField.field_name"><code class="name">var <span class="ident">field_name</span> : str</code></dt>
<dd>
<div class="desc"><p>The name of the field as specified in the input file</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.RawField.is_date"><code class="name">var <span class="ident">is_date</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether the field is a date and therefore is the index of the DataSource</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.RawField.date_format"><code class="name">var <span class="ident">date_format</span> : str</code></dt>
<dd>
<div class="desc"><p>What format the date is presented in if the field is a date</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.RawField.preprocessing_options"><code class="name">var <span class="ident">preprocessing_options</span> : Union[<a title="nowcastlib.pipeline.structs.ProcessingOptions" href="#nowcastlib.pipeline.structs.ProcessingOptions">ProcessingOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for how to pre-process the field</p>
<p>If <code>None</code>, no preprocessing will be performed.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.RawField.postprocessing_options"><code class="name">var <span class="ident">postprocessing_options</span> : Union[<a title="nowcastlib.pipeline.structs.ProcessingOptions" href="#nowcastlib.pipeline.structs.ProcessingOptions">ProcessingOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for how to post-process the field</p>
<p>If <code>None</code>, no post-processing will be performed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.RawField.no_processing"><code class="name flex">
<span>def <span class="ident">no_processing</span></span>(<span>self, _attribute, value)</span>
</code></dt>
<dd>
<div class="desc"><p>no processing or standardization to be performed when is_date is true</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@is_date.validator
def no_processing(self, _attribute, value):
    &#34;&#34;&#34;no processing or standardization to be performed when is_date is true&#34;&#34;&#34;
    if (value is True) and (
        (self.preprocessing_options is not None)
        or (self.postprocessing_options is not None)
        or (self.std_options is not None)
    ):
        raise ValueError(
            &#34;Cannot perform any standardization or (pre/post)processing on a date field.&#34;
            &#34;Please ensure that `std_options`, `preprocessing_options`,&#34;
            &#34; and `postprocessing_options` are all `None` for the field {}.&#34;
            &#34; Alternatively ensure `is_date` is `False`&#34;.format(self.field_name)
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nowcastlib.pipeline.structs.BaseField" href="#nowcastlib.pipeline.structs.BaseField">BaseField</a></b></code>:
<ul class="hlist">
<li><code><a title="nowcastlib.pipeline.structs.BaseField.std_options" href="#nowcastlib.pipeline.structs.BaseField.std_options">std_options</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nowcastlib.pipeline.structs.SerializationOptions"><code class="flex name class">
<span>class <span class="ident">SerializationOptions</span></span>
<span>(</span><span>*, output_format: str, output_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for
serializing a given DataSource to disk</p>
<p>Method generated by attrs for class SerializationOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerializationOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for
    serializing a given DataSource to disk
    &#34;&#34;&#34;

    output_format: str = attrib(validator=validators.in_([&#34;csv&#34;, &#34;pickle&#34;, &#34;npy&#34;]))
    &#34;&#34;&#34;
    One of &#39;csv&#39;, &#39;pickle&#39; or &#39;npy&#39; to specify what format
    to save the DataSource as
    &#34;&#34;&#34;
    output_path: str = attrib()
    &#34;&#34;&#34;
    The desired path to the output file, including the name.
    Folders containing the output file should exist before running.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.SerializationOptions.output_format"><code class="name">var <span class="ident">output_format</span> : str</code></dt>
<dd>
<div class="desc"><p>One of 'csv', 'pickle' or 'npy' to specify what format
to save the DataSource as</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SerializationOptions.output_path"><code class="name">var <span class="ident">output_path</span> : str</code></dt>
<dd>
<div class="desc"><p>The desired path to the output file, including the name.
Folders containing the output file should exist before running.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSource"><code class="flex name class">
<span>class <span class="ident">DataSource</span></span>
<span>(</span><span>*, name: str, path: str, fields: Tuple[<a title="nowcastlib.pipeline.structs.RawField" href="#nowcastlib.pipeline.structs.RawField">RawField</a>, ...], comment_format: str = '#', preprocessing_output: Union[<a title="nowcastlib.pipeline.structs.SerializationOptions" href="#nowcastlib.pipeline.structs.SerializationOptions">SerializationOptions</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for processing
an individual Data Source</p>
<p>Method generated by attrs for class DataSource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataSource:
    &#34;&#34;&#34;
    Struct containing configuration attributes for processing
    an individual Data Source
    &#34;&#34;&#34;

    name: str = attrib()
    &#34;&#34;&#34;The name of the DataSource. Somewhat arbitrary but useful for legibility&#34;&#34;&#34;
    path: str = attrib()
    &#34;&#34;&#34;The path to the csv file from which to read the data&#34;&#34;&#34;
    fields: Tuple[RawField, ...] = attrib()
    &#34;&#34;&#34;Configuration options for each field the user is interested in&#34;&#34;&#34;
    comment_format: str = attrib(default=&#34;#&#34;)
    &#34;&#34;&#34;Prefix used in csv file to signal comments, that will be dropped when reading&#34;&#34;&#34;
    preprocessing_output: Optional[SerializationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for saving the preprocessing results to disk.
    \nIf `None`, no serialization of the preprocessing results will be performed.
    &#34;&#34;&#34;

    @fields.validator
    def _exactly_one_date(self, attribute, value):
        &#34;&#34;&#34;checks whether maximum one of the fields contains date information&#34;&#34;&#34;
        date_flags = [field.is_date for field in value if field.is_date]
        if len(date_flags) &gt; 1:
            raise ValueError(
                &#34;{0} of the {1} instance must contain exactly one RawField with&#34;
                &#34; is_date=True&#34;.format(attribute.name, self.__class__.__name__)
            )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.DataSource.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The name of the DataSource. Somewhat arbitrary but useful for legibility</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSource.path"><code class="name">var <span class="ident">path</span> : str</code></dt>
<dd>
<div class="desc"><p>The path to the csv file from which to read the data</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSource.fields"><code class="name">var <span class="ident">fields</span> : Tuple[<a title="nowcastlib.pipeline.structs.RawField" href="#nowcastlib.pipeline.structs.RawField">RawField</a>, ...]</code></dt>
<dd>
<div class="desc"><p>Configuration options for each field the user is interested in</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSource.comment_format"><code class="name">var <span class="ident">comment_format</span> : str</code></dt>
<dd>
<div class="desc"><p>Prefix used in csv file to signal comments, that will be dropped when reading</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSource.preprocessing_output"><code class="name">var <span class="ident">preprocessing_output</span> : Union[<a title="nowcastlib.pipeline.structs.SerializationOptions" href="#nowcastlib.pipeline.structs.SerializationOptions">SerializationOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for saving the preprocessing results to disk.</p>
<p>If <code>None</code>, no serialization of the preprocessing results will be performed.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.ChunkOptions"><code class="flex name class">
<span>class <span class="ident">ChunkOptions</span></span>
<span>(</span><span>*, max_gap_size: int, min_chunk_size: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for chunking
a partially synchronized DataSet</p>
<p>Method generated by attrs for class ChunkOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChunkOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for chunking
    a partially synchronized DataSet
    &#34;&#34;&#34;

    max_gap_size: int = attrib()
    &#34;&#34;&#34;
    The maximum amount of time in seconds for a gap to be ignored
    &#34;&#34;&#34;
    min_chunk_size: int = attrib()
    &#34;&#34;&#34;
    The minimum length in seconds for contiguous block of data
    to be considered.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.ChunkOptions.max_gap_size"><code class="name">var <span class="ident">max_gap_size</span> : int</code></dt>
<dd>
<div class="desc"><p>The maximum amount of time in seconds for a gap to be ignored</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.ChunkOptions.min_chunk_size"><code class="name">var <span class="ident">min_chunk_size</span> : int</code></dt>
<dd>
<div class="desc"><p>The minimum length in seconds for contiguous block of data
to be considered.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.SyncOptions"><code class="flex name class">
<span>class <span class="ident">SyncOptions</span></span>
<span>(</span><span>*, sample_spacing: int, chunk_options: <a title="nowcastlib.pipeline.structs.ChunkOptions" href="#nowcastlib.pipeline.structs.ChunkOptions">ChunkOptions</a>, data_output: Union[<a title="nowcastlib.pipeline.structs.SerializationOptions" href="#nowcastlib.pipeline.structs.SerializationOptions">SerializationOptions</a>, NoneType] = None, chunks_output: Union[<a title="nowcastlib.pipeline.structs.SerializationOptions" href="#nowcastlib.pipeline.structs.SerializationOptions">SerializationOptions</a>, NoneType] = None, diagnostic_plots: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for synchronizing
a DataSet</p>
<p>Method generated by attrs for class SyncOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SyncOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for synchronizing
    a DataSet
    &#34;&#34;&#34;

    sample_spacing: int = attrib()
    &#34;&#34;&#34;
    The desired amount of time in seconds between each sample.
    \nIf `None`, no re-sampling will be performed.
    &#34;&#34;&#34;
    chunk_options: ChunkOptions = attrib()
    &#34;&#34;&#34;
    Configuration options necessary for handling chunking operations.
    &#34;&#34;&#34;
    data_output: Optional[SerializationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for saving the resulting
    synchronized dataframe to disk.
    \nIf `None`, no serialization of the preprocessing results will be performed.
    &#34;&#34;&#34;
    chunks_output: Optional[SerializationOptions] = attrib(
        default=None, validator=_enforce_npy
    )
    &#34;&#34;&#34;
    Configuration options for saving the detected
    chunk locations to disk. Only &#39;npy&#39; output_format
    is accepted.
    \nIf `None`, no serialization of the preprocessing results will be performed.
    &#34;&#34;&#34;
    diagnostic_plots: bool = attrib(default=True)
    &#34;&#34;&#34;
    Whether or not to show diagnostic plots, intended to help
    the user in configuration evaluation and decision making.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.SyncOptions.sample_spacing"><code class="name">var <span class="ident">sample_spacing</span> : int</code></dt>
<dd>
<div class="desc"><p>The desired amount of time in seconds between each sample.</p>
<p>If <code>None</code>, no re-sampling will be performed.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SyncOptions.chunk_options"><code class="name">var <span class="ident">chunk_options</span> : <a title="nowcastlib.pipeline.structs.ChunkOptions" href="#nowcastlib.pipeline.structs.ChunkOptions">ChunkOptions</a></code></dt>
<dd>
<div class="desc"><p>Configuration options necessary for handling chunking operations.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SyncOptions.data_output"><code class="name">var <span class="ident">data_output</span> : Union[<a title="nowcastlib.pipeline.structs.SerializationOptions" href="#nowcastlib.pipeline.structs.SerializationOptions">SerializationOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for saving the resulting
synchronized dataframe to disk.</p>
<p>If <code>None</code>, no serialization of the preprocessing results will be performed.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SyncOptions.chunks_output"><code class="name">var <span class="ident">chunks_output</span> : Union[<a title="nowcastlib.pipeline.structs.SerializationOptions" href="#nowcastlib.pipeline.structs.SerializationOptions">SerializationOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for saving the detected
chunk locations to disk. Only 'npy' output_format
is accepted.</p>
<p>If <code>None</code>, no serialization of the preprocessing results will be performed.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SyncOptions.diagnostic_plots"><code class="name">var <span class="ident">diagnostic_plots</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether or not to show diagnostic plots, intended to help
the user in configuration evaluation and decision making.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.ValidationOptions"><code class="flex name class">
<span>class <span class="ident">ValidationOptions</span></span>
<span>(</span><span>*, train_extent: float = 0.6, val_extent: float = 0.1, iterations: int = 5)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for
configuring model validation</p>
<p>Method generated by attrs for class ValidationOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidationOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for
    configuring model validation
    &#34;&#34;&#34;

    train_extent: float = attrib(default=0.6, validator=[_normed_val])
    &#34;&#34;&#34;
    Percentage of the data to allocate to the training set.
    &#34;&#34;&#34;
    val_extent: float = attrib(default=0.1, validator=[_normed_val])
    &#34;&#34;&#34;
    Percentage of the data to allocate to the validation set.
    &#34;&#34;&#34;
    iterations: int = attrib(default=5)
    &#34;&#34;&#34;
    How many splits to make. Must be at least 3.
    &#34;&#34;&#34;

    @iterations.validator
    def at_least_3(self, attribute, value):
        &#34;&#34;&#34;ensures at least 3 iterations are used for validation&#34;&#34;&#34;
        if value &lt; 3:
            raise ValueError(
                &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance needs to be at least 3.&#34;
                &#34; A value of {2} was passed instead.&#34;.format(
                    attribute.name, self.__class__.__name__, value
                )
            )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.ValidationOptions.train_extent"><code class="name">var <span class="ident">train_extent</span> : float</code></dt>
<dd>
<div class="desc"><p>Percentage of the data to allocate to the training set.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.ValidationOptions.val_extent"><code class="name">var <span class="ident">val_extent</span> : float</code></dt>
<dd>
<div class="desc"><p>Percentage of the data to allocate to the validation set.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.ValidationOptions.iterations"><code class="name">var <span class="ident">iterations</span> : int</code></dt>
<dd>
<div class="desc"><p>How many splits to make. Must be at least 3.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.ValidationOptions.at_least_3"><code class="name flex">
<span>def <span class="ident">at_least_3</span></span>(<span>self, attribute, value)</span>
</code></dt>
<dd>
<div class="desc"><p>ensures at least 3 iterations are used for validation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@iterations.validator
def at_least_3(self, attribute, value):
    &#34;&#34;&#34;ensures at least 3 iterations are used for validation&#34;&#34;&#34;
    if value &lt; 3:
        raise ValueError(
            &#34;&#39;{0}&#39; of the &#39;{1}&#39; instance needs to be at least 3.&#34;
            &#34; A value of {2} was passed instead.&#34;.format(
                attribute.name, self.__class__.__name__, value
            )
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.DirSerializationOptions"><code class="flex name class">
<span>class <span class="ident">DirSerializationOptions</span></span>
<span>(</span><span>*, parent_path: str, overwrite: bool = False, create_parents: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct configuration attributes for serializing
to specific directories, used for organizing splits</p>
<p>Method generated by attrs for class DirSerializationOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirSerializationOptions:
    &#34;&#34;&#34;
    Struct configuration attributes for serializing
    to specific directories, used for organizing splits
    &#34;&#34;&#34;

    parent_path: str = attrib()
    &#34;&#34;&#34;
    The path to the directory where to serialize the resulting splits.
    Within the directory, 2 subdirectories will be created: `main_split/`
    and `cv_split`, respectively storing the main split and the cross
    validation split.
    &#34;&#34;&#34;
    overwrite: bool = attrib(default=False)
    &#34;&#34;&#34;
    Whether to overwrite existing directories and files if they exist
    already. Default `False`
    &#34;&#34;&#34;
    create_parents: bool = attrib(default=False)
    &#34;&#34;&#34;
    Whether parent directories of `parent_path` should be created
    if they do not exist
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.DirSerializationOptions.parent_path"><code class="name">var <span class="ident">parent_path</span> : str</code></dt>
<dd>
<div class="desc"><p>The path to the directory where to serialize the resulting splits.
Within the directory, 2 subdirectories will be created: <code>main_split/</code>
and <code>cv_split</code>, respectively storing the main split and the cross
validation split.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DirSerializationOptions.overwrite"><code class="name">var <span class="ident">overwrite</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether to overwrite existing directories and files if they exist
already. Default <code>False</code></p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DirSerializationOptions.create_parents"><code class="name">var <span class="ident">create_parents</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether parent directories of <code>parent_path</code> should be created
if they do not exist</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.SplitOptions"><code class="flex name class">
<span>class <span class="ident">SplitOptions</span></span>
<span>(</span><span>*, train_split: Union[int, float, str], validation: <a title="nowcastlib.pipeline.structs.ValidationOptions" href="#nowcastlib.pipeline.structs.ValidationOptions">ValidationOptions</a>, output_options: Union[<a title="nowcastlib.pipeline.structs.DirSerializationOptions" href="#nowcastlib.pipeline.structs.DirSerializationOptions">DirSerializationOptions</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for
model evaluation</p>
<p>Method generated by attrs for class SplitOptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SplitOptions:
    &#34;&#34;&#34;
    Struct containing configuration attributes for
    model evaluation
    &#34;&#34;&#34;

    train_split: Union[int, float, str] = attrib()
    &#34;&#34;&#34;
    The index, percentage or date to use as the final
    point in the training set. The closest non-nan row will be used.
    &#34;&#34;&#34;
    validation: ValidationOptions = attrib()
    &#34;&#34;&#34;
    Configuration options for further splits of the data for validation.
    &#34;&#34;&#34;
    output_options: Optional[DirSerializationOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for serializing the resulting splits
    in organized directories.
    \nIf `None`, no serialization will be performed.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.SplitOptions.train_split"><code class="name">var <span class="ident">train_split</span> : Union[int, float, str]</code></dt>
<dd>
<div class="desc"><p>The index, percentage or date to use as the final
point in the training set. The closest non-nan row will be used.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SplitOptions.validation"><code class="name">var <span class="ident">validation</span> : <a title="nowcastlib.pipeline.structs.ValidationOptions" href="#nowcastlib.pipeline.structs.ValidationOptions">ValidationOptions</a></code></dt>
<dd>
<div class="desc"><p>Configuration options for further splits of the data for validation.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.SplitOptions.output_options"><code class="name">var <span class="ident">output_options</span> : Union[<a title="nowcastlib.pipeline.structs.DirSerializationOptions" href="#nowcastlib.pipeline.structs.DirSerializationOptions">DirSerializationOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for serializing the resulting splits
in organized directories.</p>
<p>If <code>None</code>, no serialization will be performed.</p></div>
</dd>
</dl>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSet"><code class="flex name class">
<span>class <span class="ident">DataSet</span></span>
<span>(</span><span>*, data_sources: Tuple[<a title="nowcastlib.pipeline.structs.DataSource" href="#nowcastlib.pipeline.structs.DataSource">DataSource</a>, ...], sync_options: Union[<a title="nowcastlib.pipeline.structs.SyncOptions" href="#nowcastlib.pipeline.structs.SyncOptions">SyncOptions</a>, NoneType] = None, split_options: Union[<a title="nowcastlib.pipeline.structs.SplitOptions" href="#nowcastlib.pipeline.structs.SplitOptions">SplitOptions</a>, NoneType] = None, generated_fields: Union[Tuple[<a title="nowcastlib.pipeline.structs.GeneratedField" href="#nowcastlib.pipeline.structs.GeneratedField">GeneratedField</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Struct containing configuration attributes for processing
a set of Data Sources</p>
<p>Method generated by attrs for class DataSet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataSet:
    &#34;&#34;&#34;
    Struct containing configuration attributes for processing
    a set of Data Sources
    &#34;&#34;&#34;

    data_sources: Tuple[DataSource, ...] = attrib()
    &#34;&#34;&#34;
    Configuration options for each of the sources of data we wish
    to process, each originating from a different file.
    &#34;&#34;&#34;
    sync_options: Optional[SyncOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configurations options for synchronizing the `data_sources`.
    \nIf `None`, no synchronization will be performed
    &#34;&#34;&#34;
    split_options: Optional[SplitOptions] = attrib(default=None)
    &#34;&#34;&#34;
    Configurations options for handling data splitting.
    \nIf `None`, no splitting will be performed
    &#34;&#34;&#34;
    generated_fields: Optional[Tuple[GeneratedField]] = attrib(default=None)
    &#34;&#34;&#34;
    Configuration options for adding new fields to the data.
    \nIf `None`, no new fields will be computed.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nowcastlib.pipeline.structs.DataSet.data_sources"><code class="name">var <span class="ident">data_sources</span> : Tuple[<a title="nowcastlib.pipeline.structs.DataSource" href="#nowcastlib.pipeline.structs.DataSource">DataSource</a>, ...]</code></dt>
<dd>
<div class="desc"><p>Configuration options for each of the sources of data we wish
to process, each originating from a different file.</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSet.sync_options"><code class="name">var <span class="ident">sync_options</span> : Union[<a title="nowcastlib.pipeline.structs.SyncOptions" href="#nowcastlib.pipeline.structs.SyncOptions">SyncOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configurations options for synchronizing the <code>data_sources</code>.</p>
<p>If <code>None</code>, no synchronization will be performed</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSet.split_options"><code class="name">var <span class="ident">split_options</span> : Union[<a title="nowcastlib.pipeline.structs.SplitOptions" href="#nowcastlib.pipeline.structs.SplitOptions">SplitOptions</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Configurations options for handling data splitting.</p>
<p>If <code>None</code>, no splitting will be performed</p></div>
</dd>
<dt id="nowcastlib.pipeline.structs.DataSet.generated_fields"><code class="name">var <span class="ident">generated_fields</span> : Union[Tuple[<a title="nowcastlib.pipeline.structs.GeneratedField" href="#nowcastlib.pipeline.structs.GeneratedField">GeneratedField</a>], NoneType]</code></dt>
<dd>
<div class="desc"><p>Configuration options for adding new fields to the data.</p>
<p>If <code>None</code>, no new fields will be computed.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nowcastlib.pipeline" href="index.html">nowcastlib.pipeline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.ConversionOptions" href="#nowcastlib.pipeline.structs.ConversionOptions">ConversionOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.ConversionOptions.conv_func" href="#nowcastlib.pipeline.structs.ConversionOptions.conv_func">conv_func</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ConversionOptions.key" href="#nowcastlib.pipeline.structs.ConversionOptions.key">key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.PeriodicOptions" href="#nowcastlib.pipeline.structs.PeriodicOptions">PeriodicOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.PeriodicOptions.period_length" href="#nowcastlib.pipeline.structs.PeriodicOptions.period_length">period_length</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.OutlierOptions" href="#nowcastlib.pipeline.structs.OutlierOptions">OutlierOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.OutlierOptions.lower" href="#nowcastlib.pipeline.structs.OutlierOptions.lower">lower</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.OutlierOptions.upper" href="#nowcastlib.pipeline.structs.OutlierOptions.upper">upper</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.OutlierOptions.quantile_based" href="#nowcastlib.pipeline.structs.OutlierOptions.quantile_based">quantile_based</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.SmoothOptions" href="#nowcastlib.pipeline.structs.SmoothOptions">SmoothOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.SmoothOptions.window_size" href="#nowcastlib.pipeline.structs.SmoothOptions.window_size">window_size</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SmoothOptions.units" href="#nowcastlib.pipeline.structs.SmoothOptions.units">units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.GeneratorFunction" href="#nowcastlib.pipeline.structs.GeneratorFunction">GeneratorFunction</a></code></h4>
<ul class="two-column">
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.T_SINCE_SUNSET" href="#nowcastlib.pipeline.structs.GeneratorFunction.T_SINCE_SUNSET">T_SINCE_SUNSET</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.SIN_T_SINCE_SUNSET" href="#nowcastlib.pipeline.structs.GeneratorFunction.SIN_T_SINCE_SUNSET">SIN_T_SINCE_SUNSET</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.COS_T_SINCE_SUNSET" href="#nowcastlib.pipeline.structs.GeneratorFunction.COS_T_SINCE_SUNSET">COS_T_SINCE_SUNSET</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.SUN_ELEVATION" href="#nowcastlib.pipeline.structs.GeneratorFunction.SUN_ELEVATION">SUN_ELEVATION</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.SIN_SEC" href="#nowcastlib.pipeline.structs.GeneratorFunction.SIN_SEC">SIN_SEC</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.COS_SEC" href="#nowcastlib.pipeline.structs.GeneratorFunction.COS_SEC">COS_SEC</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.SIN_DAY_YEAR" href="#nowcastlib.pipeline.structs.GeneratorFunction.SIN_DAY_YEAR">SIN_DAY_YEAR</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.COS_DAY_YEAR" href="#nowcastlib.pipeline.structs.GeneratorFunction.COS_DAY_YEAR">COS_DAY_YEAR</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.SIN_DAY_WEEK" href="#nowcastlib.pipeline.structs.GeneratorFunction.SIN_DAY_WEEK">SIN_DAY_WEEK</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.COS_DAY_WEEK" href="#nowcastlib.pipeline.structs.GeneratorFunction.COS_DAY_WEEK">COS_DAY_WEEK</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.SIN_MONTH_YEAR" href="#nowcastlib.pipeline.structs.GeneratorFunction.SIN_MONTH_YEAR">SIN_MONTH_YEAR</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.COS_MONTH_YEAR" href="#nowcastlib.pipeline.structs.GeneratorFunction.COS_MONTH_YEAR">COS_MONTH_YEAR</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.IS_WEEKEND" href="#nowcastlib.pipeline.structs.GeneratorFunction.IS_WEEKEND">IS_WEEKEND</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratorFunction.CUSTOM" href="#nowcastlib.pipeline.structs.GeneratorFunction.CUSTOM">CUSTOM</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.StandardizationMethod" href="#nowcastlib.pipeline.structs.StandardizationMethod">StandardizationMethod</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.StandardizationMethod.POWER" href="#nowcastlib.pipeline.structs.StandardizationMethod.POWER">POWER</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.StandardizationMethod.ROBUST" href="#nowcastlib.pipeline.structs.StandardizationMethod.ROBUST">ROBUST</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.StandardizationMethod.LOGNORM" href="#nowcastlib.pipeline.structs.StandardizationMethod.LOGNORM">LOGNORM</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.StandardizationOptions" href="#nowcastlib.pipeline.structs.StandardizationOptions">StandardizationOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.StandardizationOptions.method" href="#nowcastlib.pipeline.structs.StandardizationOptions.method">method</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.StandardizationOptions.diagnostic_plots" href="#nowcastlib.pipeline.structs.StandardizationOptions.diagnostic_plots">diagnostic_plots</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.BaseField" href="#nowcastlib.pipeline.structs.BaseField">BaseField</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.BaseField.std_options" href="#nowcastlib.pipeline.structs.BaseField.std_options">std_options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.GeneratedField" href="#nowcastlib.pipeline.structs.GeneratedField">GeneratedField</a></code></h4>
<ul class="two-column">
<li><code><a title="nowcastlib.pipeline.structs.GeneratedField.only_if_custom" href="#nowcastlib.pipeline.structs.GeneratedField.only_if_custom">only_if_custom</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratedField.target_name" href="#nowcastlib.pipeline.structs.GeneratedField.target_name">target_name</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratedField.input_fields" href="#nowcastlib.pipeline.structs.GeneratedField.input_fields">input_fields</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratedField.gen_func" href="#nowcastlib.pipeline.structs.GeneratedField.gen_func">gen_func</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratedField.additional_kwargs" href="#nowcastlib.pipeline.structs.GeneratedField.additional_kwargs">additional_kwargs</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.GeneratedField.func_path" href="#nowcastlib.pipeline.structs.GeneratedField.func_path">func_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.ProcessingOptions" href="#nowcastlib.pipeline.structs.ProcessingOptions">ProcessingOptions</a></code></h4>
<ul class="two-column">
<li><code><a title="nowcastlib.pipeline.structs.ProcessingOptions.prevent_overwrite" href="#nowcastlib.pipeline.structs.ProcessingOptions.prevent_overwrite">prevent_overwrite</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ProcessingOptions.overwrite" href="#nowcastlib.pipeline.structs.ProcessingOptions.overwrite">overwrite</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ProcessingOptions.outlier_options" href="#nowcastlib.pipeline.structs.ProcessingOptions.outlier_options">outlier_options</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ProcessingOptions.periodic_options" href="#nowcastlib.pipeline.structs.ProcessingOptions.periodic_options">periodic_options</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ProcessingOptions.conversion_options" href="#nowcastlib.pipeline.structs.ProcessingOptions.conversion_options">conversion_options</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ProcessingOptions.smooth_options" href="#nowcastlib.pipeline.structs.ProcessingOptions.smooth_options">smooth_options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.RawField" href="#nowcastlib.pipeline.structs.RawField">RawField</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.RawField.no_processing" href="#nowcastlib.pipeline.structs.RawField.no_processing">no_processing</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.RawField.field_name" href="#nowcastlib.pipeline.structs.RawField.field_name">field_name</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.RawField.is_date" href="#nowcastlib.pipeline.structs.RawField.is_date">is_date</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.RawField.date_format" href="#nowcastlib.pipeline.structs.RawField.date_format">date_format</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.RawField.preprocessing_options" href="#nowcastlib.pipeline.structs.RawField.preprocessing_options">preprocessing_options</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.RawField.postprocessing_options" href="#nowcastlib.pipeline.structs.RawField.postprocessing_options">postprocessing_options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.SerializationOptions" href="#nowcastlib.pipeline.structs.SerializationOptions">SerializationOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.SerializationOptions.output_format" href="#nowcastlib.pipeline.structs.SerializationOptions.output_format">output_format</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SerializationOptions.output_path" href="#nowcastlib.pipeline.structs.SerializationOptions.output_path">output_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.DataSource" href="#nowcastlib.pipeline.structs.DataSource">DataSource</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.DataSource.name" href="#nowcastlib.pipeline.structs.DataSource.name">name</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DataSource.path" href="#nowcastlib.pipeline.structs.DataSource.path">path</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DataSource.fields" href="#nowcastlib.pipeline.structs.DataSource.fields">fields</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DataSource.comment_format" href="#nowcastlib.pipeline.structs.DataSource.comment_format">comment_format</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DataSource.preprocessing_output" href="#nowcastlib.pipeline.structs.DataSource.preprocessing_output">preprocessing_output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.ChunkOptions" href="#nowcastlib.pipeline.structs.ChunkOptions">ChunkOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.ChunkOptions.max_gap_size" href="#nowcastlib.pipeline.structs.ChunkOptions.max_gap_size">max_gap_size</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ChunkOptions.min_chunk_size" href="#nowcastlib.pipeline.structs.ChunkOptions.min_chunk_size">min_chunk_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.SyncOptions" href="#nowcastlib.pipeline.structs.SyncOptions">SyncOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.SyncOptions.sample_spacing" href="#nowcastlib.pipeline.structs.SyncOptions.sample_spacing">sample_spacing</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SyncOptions.chunk_options" href="#nowcastlib.pipeline.structs.SyncOptions.chunk_options">chunk_options</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SyncOptions.data_output" href="#nowcastlib.pipeline.structs.SyncOptions.data_output">data_output</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SyncOptions.chunks_output" href="#nowcastlib.pipeline.structs.SyncOptions.chunks_output">chunks_output</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SyncOptions.diagnostic_plots" href="#nowcastlib.pipeline.structs.SyncOptions.diagnostic_plots">diagnostic_plots</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.ValidationOptions" href="#nowcastlib.pipeline.structs.ValidationOptions">ValidationOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.ValidationOptions.at_least_3" href="#nowcastlib.pipeline.structs.ValidationOptions.at_least_3">at_least_3</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ValidationOptions.train_extent" href="#nowcastlib.pipeline.structs.ValidationOptions.train_extent">train_extent</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ValidationOptions.val_extent" href="#nowcastlib.pipeline.structs.ValidationOptions.val_extent">val_extent</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.ValidationOptions.iterations" href="#nowcastlib.pipeline.structs.ValidationOptions.iterations">iterations</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.DirSerializationOptions" href="#nowcastlib.pipeline.structs.DirSerializationOptions">DirSerializationOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.DirSerializationOptions.parent_path" href="#nowcastlib.pipeline.structs.DirSerializationOptions.parent_path">parent_path</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DirSerializationOptions.overwrite" href="#nowcastlib.pipeline.structs.DirSerializationOptions.overwrite">overwrite</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DirSerializationOptions.create_parents" href="#nowcastlib.pipeline.structs.DirSerializationOptions.create_parents">create_parents</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.SplitOptions" href="#nowcastlib.pipeline.structs.SplitOptions">SplitOptions</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.SplitOptions.train_split" href="#nowcastlib.pipeline.structs.SplitOptions.train_split">train_split</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SplitOptions.validation" href="#nowcastlib.pipeline.structs.SplitOptions.validation">validation</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.SplitOptions.output_options" href="#nowcastlib.pipeline.structs.SplitOptions.output_options">output_options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nowcastlib.pipeline.structs.DataSet" href="#nowcastlib.pipeline.structs.DataSet">DataSet</a></code></h4>
<ul class="">
<li><code><a title="nowcastlib.pipeline.structs.DataSet.data_sources" href="#nowcastlib.pipeline.structs.DataSet.data_sources">data_sources</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DataSet.sync_options" href="#nowcastlib.pipeline.structs.DataSet.sync_options">sync_options</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DataSet.split_options" href="#nowcastlib.pipeline.structs.DataSet.split_options">split_options</a></code></li>
<li><code><a title="nowcastlib.pipeline.structs.DataSet.generated_fields" href="#nowcastlib.pipeline.structs.DataSet.generated_fields">generated_fields</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>