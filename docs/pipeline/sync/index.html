<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nowcastlib.pipeline.sync API documentation</title>
<meta name="description" content="Functions for synchronizing data" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nowcastlib.pipeline.sync</code></h1>
</header>
<section id="section-intro">
<p>Functions for synchronizing data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions for synchronizing data
&#34;&#34;&#34;
import sys
import logging
from typing import Optional, List
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from nowcastlib.pipeline import structs
from nowcastlib.pipeline.process import preprocess
from nowcastlib.pipeline import utils
from nowcastlib import datasets

plt.ion()
logger = logging.getLogger(__name__)


def handle_diag_plots(
    config: structs.SyncOptions, dataframes: List[pd.core.frame.DataFrame]
):
    &#34;&#34;&#34;
    Produces plots that can aid the user in noticing mistakes
    in their configuration before proceeding with the
    synchronization process

    Parameters
    ----------
    config : nowcastlib.pipeline.structs.SyncOptions
    dataframes : list[pandas.core.frame.DataFrame]
        The set of dataframes one wishes to synchronize.

    Returns
    -------
    bool
        whether the user wishes to continue with
        running the pipeline or not
    &#34;&#34;&#34;
    n_samples = 10000
    fig, ax1 = plt.subplots(1, 1, figsize=(6, 4))
    for i, data_df in enumerate(dataframes):
        sample_spacing = data_df.index.to_series().diff()
        data = sample_spacing.sample(n_samples).astype(&#34;timedelta64[s]&#34;)
        weights = np.ones_like(data) / n_samples
        ax1.hist(
            data,
            bins=np.arange(150, step=1),
            weights=weights,
            label=&#34;DataSource {} sample spacing&#34;.format(i),
            histtype=&#34;step&#34;,
            linewidth=1.5,
        )
    ax1.axvline(config.sample_spacing, color=&#34;black&#34;, label=&#34;Selected Sample Spacing&#34;)
    ax1.set_xlabel(&#34;Sample Spacing [s]&#34;)
    ax1.set_ylabel(&#34;Prevalence&#34;)
    ax1.set_title(
        &#34;Sample spacing of {} random samples across the input Data Sources&#34;.format(
            n_samples
        )
    )
    ax1.legend()
    fig.set_tight_layout(True)
    logger.info(&#34;Press any button to exit. Use mouse to zoom and resize&#34;)
    while True:
        plt.draw()
        if plt.waitforbuttonpress():
            break
    return utils.yes_or_no(&#34;Are you satisfied with the target sample rate?&#34;)


def handle_chunking(
    data_df: pd.core.frame.DataFrame,
    config: structs.ChunkOptions,
    column_names: Optional[List[str]] = None,
):
    &#34;&#34;&#34;
    Finds overlapping chunks of data across dataframe columns,
    taking into account gap size preferences.

    Parameters
    ----------
    data_df: pandas.core.frame.DataFrame
        the sparse dataframe to perform chunking on
    config : nowcastlib.pipeline.structs.ChunkOptions
        chunking configuration options
    column_names : list[str], default None
        the names of the columns to check for overlaps.
        If `None`, all columns will be used.

    Returns
    -------
    pandas.core.frame.DataFrame
        The resulting dataframe, rows where not
        all columns contained data now contain NaN
        across all columns, depending on gap preferences.
    numpy.ndarray
        2D numpy array containing the start and end
        integer indices of the contiguous chunks of data
        in the input dataframe. Shape is (-1, 2).
    &#34;&#34;&#34;
    # find overlapping data, ignoring small gaps
    sample_spacing_secs = data_df.index.freq.delta.seconds
    max_spacing_steps = np.floor((config.max_gap_size / sample_spacing_secs)).astype(
        int
    )
    min_chunk_length = int(config.min_chunk_size / sample_spacing_secs)
    final_mask, chunk_locs = datasets.compute_dataframe_mask(
        data_df, max_spacing_steps, min_chunk_length, 0, column_names
    )
    # imputing gaps, restoring large gaps
    interpolated_df = data_df.interpolate(&#34;linear&#34;, limit_direction=&#34;both&#34;)
    chunked_df = interpolated_df.where(final_mask)  # type: ignore

    return chunked_df, chunk_locs


def synchronize_dataset(
    config: structs.DataSet, dataset: Optional[List[pd.core.frame.DataFrame]] = None
):
    &#34;&#34;&#34;
    Synchronizes a set of data sources given options outlined
    in the input DataSet config instance. Optionally writes the
    results to disk.

    Parameters
    ----------
    config : nowcastlib.pipeline.structs.DataSet
    dataset : list[pandas.core.frame.DataFrame], default None
        The set of dataframes one wishes to synchronize.
        If `None`, the preprocessing output produced by the
        config options will be synchronized.

    Returns
    -------
    pandas.core.frame.DataFrame
        A single dataframe containing the
        synchronized data. The dataframe is sparse,
        with individual rows comprising solely of NaNs.
    numpy.ndarray
        2D numpy array containing the start and end
        integer indices of the contiguous chunks of data
        in the input dataframe. Shape is (-1, 2).
    &#34;&#34;&#34;
    sync_config = config.sync_options
    assert (
        sync_config is not None
    ), &#34;`config.sync_options` must be defined to perform synchronization&#34;
    # avoid preprocessing if datasets are passed directly
    if dataset is None:
        data_dfs = preprocess.preprocess_dataset(config)
    else:
        data_dfs = dataset
    logger.info(&#34;Synchronizing dataset...&#34;)

    if sync_config.diagnostic_plots is not False:
        continue_processing = handle_diag_plots(sync_config, data_dfs)
        if continue_processing is False:
            logger.info(
                &#34;Closing program prematurely to allow for configuration changes&#34;
            )
            sys.exit()

    total_dfs = len(data_dfs)
    resampled_dfs = []
    for i, data_df in enumerate(data_dfs):
        logger.debug(&#34;Resampling DataSource %d of %d...&#34;, i + 1, total_dfs)
        data_df.index.name = None
        offset_str = &#34;{}S&#34;.format(sync_config.sample_spacing)
        resampled_dfs.append(
            data_df.resample(
                offset_str,
                origin=data_df.index[0].floor(offset_str),
            ).mean()
        )
    logger.debug(&#34;Finding overlapping range and joining into single dataframe...&#34;)
    synced_df = pd.concat(resampled_dfs, axis=1, join=&#34;inner&#34;)
    logger.debug(&#34;Splitting data into contiguous chunks...&#34;)
    chunked_df, chunk_locs = handle_chunking(
        synced_df, sync_config.chunk_options, [df.columns[0] for df in data_dfs]
    )
    if sync_config.data_output is not None:
        logger.debug(&#34;Serializing chunked dataframe...&#34;)
        utils.handle_serialization(chunked_df, sync_config.data_output)
    if sync_config.chunks_output is not None:
        logger.debug(&#34;Serializing chunk locations...&#34;)
        utils.handle_serialization(chunk_locs, sync_config.chunks_output)
    return chunked_df, chunk_locs</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="nowcastlib.pipeline.sync.cli" href="cli.html">nowcastlib.pipeline.sync.cli</a></code></dt>
<dd>
<div class="desc"><p>Command-Line interface functionality for synchronization</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nowcastlib.pipeline.sync.handle_diag_plots"><code class="name flex">
<span>def <span class="ident">handle_diag_plots</span></span>(<span>config: <a title="nowcastlib.pipeline.structs.SyncOptions" href="../structs.html#nowcastlib.pipeline.structs.SyncOptions">SyncOptions</a>, dataframes: List[pandas.core.frame.DataFrame])</span>
</code></dt>
<dd>
<div class="desc"><p>Produces plots that can aid the user in noticing mistakes
in their configuration before proceeding with the
synchronization process</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="nowcastlib.pipeline.structs.SyncOptions" href="../structs.html#nowcastlib.pipeline.structs.SyncOptions">SyncOptions</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dataframes</code></strong> :&ensp;<code>list[pandas.core.frame.DataFrame]</code></dt>
<dd>The set of dataframes one wishes to synchronize.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>whether the user wishes to continue with
running the pipeline or not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_diag_plots(
    config: structs.SyncOptions, dataframes: List[pd.core.frame.DataFrame]
):
    &#34;&#34;&#34;
    Produces plots that can aid the user in noticing mistakes
    in their configuration before proceeding with the
    synchronization process

    Parameters
    ----------
    config : nowcastlib.pipeline.structs.SyncOptions
    dataframes : list[pandas.core.frame.DataFrame]
        The set of dataframes one wishes to synchronize.

    Returns
    -------
    bool
        whether the user wishes to continue with
        running the pipeline or not
    &#34;&#34;&#34;
    n_samples = 10000
    fig, ax1 = plt.subplots(1, 1, figsize=(6, 4))
    for i, data_df in enumerate(dataframes):
        sample_spacing = data_df.index.to_series().diff()
        data = sample_spacing.sample(n_samples).astype(&#34;timedelta64[s]&#34;)
        weights = np.ones_like(data) / n_samples
        ax1.hist(
            data,
            bins=np.arange(150, step=1),
            weights=weights,
            label=&#34;DataSource {} sample spacing&#34;.format(i),
            histtype=&#34;step&#34;,
            linewidth=1.5,
        )
    ax1.axvline(config.sample_spacing, color=&#34;black&#34;, label=&#34;Selected Sample Spacing&#34;)
    ax1.set_xlabel(&#34;Sample Spacing [s]&#34;)
    ax1.set_ylabel(&#34;Prevalence&#34;)
    ax1.set_title(
        &#34;Sample spacing of {} random samples across the input Data Sources&#34;.format(
            n_samples
        )
    )
    ax1.legend()
    fig.set_tight_layout(True)
    logger.info(&#34;Press any button to exit. Use mouse to zoom and resize&#34;)
    while True:
        plt.draw()
        if plt.waitforbuttonpress():
            break
    return utils.yes_or_no(&#34;Are you satisfied with the target sample rate?&#34;)</code></pre>
</details>
</dd>
<dt id="nowcastlib.pipeline.sync.handle_chunking"><code class="name flex">
<span>def <span class="ident">handle_chunking</span></span>(<span>data_df: pandas.core.frame.DataFrame, config: <a title="nowcastlib.pipeline.structs.ChunkOptions" href="../structs.html#nowcastlib.pipeline.structs.ChunkOptions">ChunkOptions</a>, column_names: Union[List[str], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds overlapping chunks of data across dataframe columns,
taking into account gap size preferences.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_df</code></strong> :&ensp;<code>pandas.core.frame.DataFrame</code></dt>
<dd>the sparse dataframe to perform chunking on</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="nowcastlib.pipeline.structs.ChunkOptions" href="../structs.html#nowcastlib.pipeline.structs.ChunkOptions">ChunkOptions</a></code></dt>
<dd>chunking configuration options</dd>
<dt><strong><code>column_names</code></strong> :&ensp;<code>list[str]</code>, default <code>None</code></dt>
<dd>the names of the columns to check for overlaps.
If <code>None</code>, all columns will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.core.frame.DataFrame</code></dt>
<dd>The resulting dataframe, rows where not
all columns contained data now contain NaN
across all columns, depending on gap preferences.</dd>
<dt><code>numpy.ndarray</code></dt>
<dd>2D numpy array containing the start and end
integer indices of the contiguous chunks of data
in the input dataframe. Shape is (-1, 2).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_chunking(
    data_df: pd.core.frame.DataFrame,
    config: structs.ChunkOptions,
    column_names: Optional[List[str]] = None,
):
    &#34;&#34;&#34;
    Finds overlapping chunks of data across dataframe columns,
    taking into account gap size preferences.

    Parameters
    ----------
    data_df: pandas.core.frame.DataFrame
        the sparse dataframe to perform chunking on
    config : nowcastlib.pipeline.structs.ChunkOptions
        chunking configuration options
    column_names : list[str], default None
        the names of the columns to check for overlaps.
        If `None`, all columns will be used.

    Returns
    -------
    pandas.core.frame.DataFrame
        The resulting dataframe, rows where not
        all columns contained data now contain NaN
        across all columns, depending on gap preferences.
    numpy.ndarray
        2D numpy array containing the start and end
        integer indices of the contiguous chunks of data
        in the input dataframe. Shape is (-1, 2).
    &#34;&#34;&#34;
    # find overlapping data, ignoring small gaps
    sample_spacing_secs = data_df.index.freq.delta.seconds
    max_spacing_steps = np.floor((config.max_gap_size / sample_spacing_secs)).astype(
        int
    )
    min_chunk_length = int(config.min_chunk_size / sample_spacing_secs)
    final_mask, chunk_locs = datasets.compute_dataframe_mask(
        data_df, max_spacing_steps, min_chunk_length, 0, column_names
    )
    # imputing gaps, restoring large gaps
    interpolated_df = data_df.interpolate(&#34;linear&#34;, limit_direction=&#34;both&#34;)
    chunked_df = interpolated_df.where(final_mask)  # type: ignore

    return chunked_df, chunk_locs</code></pre>
</details>
</dd>
<dt id="nowcastlib.pipeline.sync.synchronize_dataset"><code class="name flex">
<span>def <span class="ident">synchronize_dataset</span></span>(<span>config: <a title="nowcastlib.pipeline.structs.DataSet" href="../structs.html#nowcastlib.pipeline.structs.DataSet">DataSet</a>, dataset: Union[List[pandas.core.frame.DataFrame], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronizes a set of data sources given options outlined
in the input DataSet config instance. Optionally writes the
results to disk.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="nowcastlib.pipeline.structs.DataSet" href="../structs.html#nowcastlib.pipeline.structs.DataSet">DataSet</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dataset</code></strong> :&ensp;<code>list[pandas.core.frame.DataFrame]</code>, default <code>None</code></dt>
<dd>The set of dataframes one wishes to synchronize.
If <code>None</code>, the preprocessing output produced by the
config options will be synchronized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.core.frame.DataFrame</code></dt>
<dd>A single dataframe containing the
synchronized data. The dataframe is sparse,
with individual rows comprising solely of NaNs.</dd>
<dt><code>numpy.ndarray</code></dt>
<dd>2D numpy array containing the start and end
integer indices of the contiguous chunks of data
in the input dataframe. Shape is (-1, 2).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synchronize_dataset(
    config: structs.DataSet, dataset: Optional[List[pd.core.frame.DataFrame]] = None
):
    &#34;&#34;&#34;
    Synchronizes a set of data sources given options outlined
    in the input DataSet config instance. Optionally writes the
    results to disk.

    Parameters
    ----------
    config : nowcastlib.pipeline.structs.DataSet
    dataset : list[pandas.core.frame.DataFrame], default None
        The set of dataframes one wishes to synchronize.
        If `None`, the preprocessing output produced by the
        config options will be synchronized.

    Returns
    -------
    pandas.core.frame.DataFrame
        A single dataframe containing the
        synchronized data. The dataframe is sparse,
        with individual rows comprising solely of NaNs.
    numpy.ndarray
        2D numpy array containing the start and end
        integer indices of the contiguous chunks of data
        in the input dataframe. Shape is (-1, 2).
    &#34;&#34;&#34;
    sync_config = config.sync_options
    assert (
        sync_config is not None
    ), &#34;`config.sync_options` must be defined to perform synchronization&#34;
    # avoid preprocessing if datasets are passed directly
    if dataset is None:
        data_dfs = preprocess.preprocess_dataset(config)
    else:
        data_dfs = dataset
    logger.info(&#34;Synchronizing dataset...&#34;)

    if sync_config.diagnostic_plots is not False:
        continue_processing = handle_diag_plots(sync_config, data_dfs)
        if continue_processing is False:
            logger.info(
                &#34;Closing program prematurely to allow for configuration changes&#34;
            )
            sys.exit()

    total_dfs = len(data_dfs)
    resampled_dfs = []
    for i, data_df in enumerate(data_dfs):
        logger.debug(&#34;Resampling DataSource %d of %d...&#34;, i + 1, total_dfs)
        data_df.index.name = None
        offset_str = &#34;{}S&#34;.format(sync_config.sample_spacing)
        resampled_dfs.append(
            data_df.resample(
                offset_str,
                origin=data_df.index[0].floor(offset_str),
            ).mean()
        )
    logger.debug(&#34;Finding overlapping range and joining into single dataframe...&#34;)
    synced_df = pd.concat(resampled_dfs, axis=1, join=&#34;inner&#34;)
    logger.debug(&#34;Splitting data into contiguous chunks...&#34;)
    chunked_df, chunk_locs = handle_chunking(
        synced_df, sync_config.chunk_options, [df.columns[0] for df in data_dfs]
    )
    if sync_config.data_output is not None:
        logger.debug(&#34;Serializing chunked dataframe...&#34;)
        utils.handle_serialization(chunked_df, sync_config.data_output)
    if sync_config.chunks_output is not None:
        logger.debug(&#34;Serializing chunk locations...&#34;)
        utils.handle_serialization(chunk_locs, sync_config.chunks_output)
    return chunked_df, chunk_locs</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nowcastlib.pipeline" href="../index.html">nowcastlib.pipeline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="nowcastlib.pipeline.sync.cli" href="cli.html">nowcastlib.pipeline.sync.cli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nowcastlib.pipeline.sync.handle_diag_plots" href="#nowcastlib.pipeline.sync.handle_diag_plots">handle_diag_plots</a></code></li>
<li><code><a title="nowcastlib.pipeline.sync.handle_chunking" href="#nowcastlib.pipeline.sync.handle_chunking">handle_chunking</a></code></li>
<li><code><a title="nowcastlib.pipeline.sync.synchronize_dataset" href="#nowcastlib.pipeline.sync.synchronize_dataset">synchronize_dataset</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>